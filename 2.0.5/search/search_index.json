{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django REST Framework Versioning This project aims to make it easy to support many different API versions in a Django REST Framework (DRF) project. DRF supports several versioning schemes but (perhaps wisely) sidesteps the issue of how to actually deal with the different versions in your code. To quote the docs: \"How you vary the API behavior is up to you\". This project provides some out-of-the box tools to handle versioning in views and serializers. The aim is to abstract away any versioning logic into a sort of \"versioning layer\" and allow the bulk of the code (and its developers) to focus on the latest behaviour. Acknowledgements The approach taken in this project was inspired by Stripe's API version \"compatibility layer\", as described in blog posts by Brandur Leach and Amber Feng . I used Ryan Kaneshiro's excellent Django sketch as a starting point. I also want to thank my colleagues at Tranzer for encouraging me to work on this, and for being my guinea pigs / code duckies \u2764\ufe0f","title":"Home"},{"location":"#django-rest-framework-versioning","text":"This project aims to make it easy to support many different API versions in a Django REST Framework (DRF) project. DRF supports several versioning schemes but (perhaps wisely) sidesteps the issue of how to actually deal with the different versions in your code. To quote the docs: \"How you vary the API behavior is up to you\". This project provides some out-of-the box tools to handle versioning in views and serializers. The aim is to abstract away any versioning logic into a sort of \"versioning layer\" and allow the bulk of the code (and its developers) to focus on the latest behaviour.","title":"Django REST Framework Versioning"},{"location":"#acknowledgements","text":"The approach taken in this project was inspired by Stripe's API version \"compatibility layer\", as described in blog posts by Brandur Leach and Amber Feng . I used Ryan Kaneshiro's excellent Django sketch as a starting point. I also want to thank my colleagues at Tranzer for encouraging me to work on this, and for being my guinea pigs / code duckies \u2764\ufe0f","title":"Acknowledgements"},{"location":"quickstart/","text":"Quick start This section is intended as a quick reference for those who want to install DRF Versioning into an existing Django project. If you are starting from scratch, I recommend following the tutorial, which includes setting up a sample Django REST project. Create a versioning module ./manage.py startapp versioning or mkdir versioning Suggested structure: \u2514\u2500\u2500 versioning \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 version_list.py # maintain the list of supported Versions here \u2514\u2500\u2500 versions.py # define your Version instances here with versions.py containing: from drf_versioning.versions import Version VERSION_1_0_0 = Version( \"1.0.0\", notes=[\"Initial version\"], ) and version_list.py containing: from . import versions VERSIONS = [ versions.VERSION_1_0_0, ] Update project settings In your project settings.py add: REST_FRAMEWORK = { \"DEFAULT_VERSIONING_CLASS\": \"drf_versioning.middleware.AcceptHeaderVersioning\", } DRF_VERSIONING_SETTINGS = { \"VERSION_LIST\": \"versioning.version_list.VERSIONS\", \"DEFAULT_VERSION\": \"latest\", } (Optional) add versioning urls In your project urls.py : urlpatterns = [ ..., # your other urls path(\"version/\", include(\"drf_versioning.urls\")), ]","title":"Quick start"},{"location":"quickstart/#quick-start","text":"This section is intended as a quick reference for those who want to install DRF Versioning into an existing Django project. If you are starting from scratch, I recommend following the tutorial, which includes setting up a sample Django REST project.","title":"Quick start"},{"location":"quickstart/#create-a-versioning-module","text":"./manage.py startapp versioning or mkdir versioning Suggested structure: \u2514\u2500\u2500 versioning \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 version_list.py # maintain the list of supported Versions here \u2514\u2500\u2500 versions.py # define your Version instances here with versions.py containing: from drf_versioning.versions import Version VERSION_1_0_0 = Version( \"1.0.0\", notes=[\"Initial version\"], ) and version_list.py containing: from . import versions VERSIONS = [ versions.VERSION_1_0_0, ]","title":"Create a versioning module"},{"location":"quickstart/#update-project-settings","text":"In your project settings.py add: REST_FRAMEWORK = { \"DEFAULT_VERSIONING_CLASS\": \"drf_versioning.middleware.AcceptHeaderVersioning\", } DRF_VERSIONING_SETTINGS = { \"VERSION_LIST\": \"versioning.version_list.VERSIONS\", \"DEFAULT_VERSION\": \"latest\", }","title":"Update project settings"},{"location":"quickstart/#optional-add-versioning-urls","text":"In your project urls.py : urlpatterns = [ ..., # your other urls path(\"version/\", include(\"drf_versioning.urls\")), ]","title":"(Optional) add versioning urls"},{"location":"reference/","text":"API Reference VersionedSerializer Bases: serializers . Serializer Source code in drf_versioning/serializers/versioned_serializer.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class VersionedSerializer ( serializers . Serializer ): transforms : tuple [ type [ Transform ]] = None def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . check_transforms_declared () def check_transforms_declared ( self ): if not self . transforms : raise TransformsNotDeclaredError ( f \" { self . __class__ . __name__ } has not declared transforms.\" ) def _get_request_version ( self ): request = self . context . get ( \"request\" ) if request and hasattr ( request , \"version\" ): return request . version def transforms_for_version ( self , version : Version , reverse = False ) -> list [ type [ Transform ]]: return sorted ( filter ( lambda transform : version < transform . version , self . transforms ), key = lambda transform : transform . version , reverse = reverse , ) def to_representation ( self , instance ): \"\"\" Serializes the outgoing data as JSON and executes any available version transforms in backwards order against the serialized representation to convert the highest supported version into the requested version of the resource. \"\"\" data = super () . to_representation ( instance ) request = self . context . get ( \"request\" ) if request_version := self . _get_request_version (): for transform in self . transforms_for_version ( version = request_version , reverse = True ): transform () . to_representation ( data , request , instance ) return data def to_internal_value ( self , data : QueryDict ): data = data . copy () # immutable QueryDict to mutable dict request = self . context . get ( \"request\" ) if request_version := self . _get_request_version (): for transform in self . transforms_for_version ( version = request_version , reverse = False ): transform () . to_internal_value ( data , request ) return super () . to_internal_value ( data ) to_representation ( instance ) Serializes the outgoing data as JSON and executes any available version transforms in backwards order against the serialized representation to convert the highest supported version into the requested version of the resource. Source code in drf_versioning/serializers/versioned_serializer.py 36 37 38 39 40 41 42 43 44 45 46 47 48 def to_representation ( self , instance ): \"\"\" Serializes the outgoing data as JSON and executes any available version transforms in backwards order against the serialized representation to convert the highest supported version into the requested version of the resource. \"\"\" data = super () . to_representation ( instance ) request = self . context . get ( \"request\" ) if request_version := self . _get_request_version (): for transform in self . transforms_for_version ( version = request_version , reverse = True ): transform () . to_representation ( data , request , instance ) return data VersionedViewSet Bases: viewsets . GenericViewSet Source code in drf_versioning/views/versioned_viewset.py 35 36 37 38 39 40 41 42 43 44 45 46 47 class VersionedViewSet ( viewsets . GenericViewSet , metaclass = VersionedViewSetMeta ): introduced_in : Optional [ Version ] = None removed_in : Optional [ Version ] = None def dispatch ( self , request , * args , ** kwargs ): request_method = request . method . lower () if request_method in self . http_method_names : handler = getattr ( self , request_method , self . http_method_not_allowed ) handler = versioned_view ( handler , introduced_in = self . introduced_in , removed_in = self . removed_in ) setattr ( self , request_method , handler ) return super () . dispatch ( request , * args , ** kwargs ) versioned_view Source code in drf_versioning/decorators/decorators.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def versioned_view ( original_obj = None , introduced_in : Version = None , removed_in : Version = None ): def decorate ( obj ): if introduced_in is None and removed_in is None : raise VersionsNotDeclaredError ( obj ) @wraps ( obj ) def func_wrapper ( * args , ** kwargs ): # if it's a bound method which we decorated dynamically: # handler = versioned_view(handler, ...) if hasattr ( obj , \"__self__\" ): request = args [ 0 ] viewset = obj . __self__ # if it's an unbound function we decorated statically at class definition: # @versioned_view(...) # def list(...): # ... else : viewset , request = args viewset_introduced_in = getattr ( viewset , \"introduced_in\" , None ) viewset_removed_in = getattr ( viewset , \"removed_in\" , None ) min_version = get_min_version ( introduced_in , viewset_introduced_in ) max_version = get_max_version ( removed_in , viewset_removed_in ) if min_version and request . version < min_version : raise Http404 () if max_version and request . version >= max_version : raise Http404 () output = obj ( * args , ** kwargs ) return output if introduced_in : introduced_in . view_methods_introduced . append ( func_wrapper ) if removed_in : removed_in . view_methods_removed . append ( func_wrapper ) return func_wrapper return decorate ( original_obj ) if original_obj else decorate Transforms Mutates serializer data between different versions Source code in drf_versioning/transforms/transform.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Transform ( metaclass = TransformMeta ): \"\"\" Mutates serializer data between different versions \"\"\" description : str # will be added to version.notes version : Version # will be added to version.transforms def to_internal_value ( self , data : dict , request ): \"\"\"Operation performed on incoming data from older request versions\"\"\" raise NotImplementedError def to_representation ( self , data : dict , request , instance ): \"\"\"Operation performed on outgoing data in response to an older request version\"\"\" raise NotImplementedError to_internal_value ( data , request ) Operation performed on incoming data from older request versions Source code in drf_versioning/transforms/transform.py 25 26 27 def to_internal_value ( self , data : dict , request ): \"\"\"Operation performed on incoming data from older request versions\"\"\" raise NotImplementedError to_representation ( data , request , instance ) Operation performed on outgoing data in response to an older request version Source code in drf_versioning/transforms/transform.py 29 30 31 def to_representation ( self , data : dict , request , instance ): \"\"\"Operation performed on outgoing data in response to an older request version\"\"\" raise NotImplementedError Bases: Transform Source code in drf_versioning/transforms/common.py 4 5 6 7 8 9 10 11 12 13 class AddField ( Transform ): field_name : str def to_internal_value ( self , data : dict , request ): data . pop ( self . field_name , None ) return data def to_representation ( self , data : dict , request , instance ): data . pop ( self . field_name , None ) return data Bases: Transform Source code in drf_versioning/transforms/common.py 16 17 18 19 20 21 22 23 24 25 26 class RemoveField ( Transform ): field_name : str null_value = None # the value to serialize for the removed field for old versions def to_internal_value ( self , data : dict , request ): data . pop ( self . field_name , None ) return data def to_representation ( self , data : dict , request , instance ): data [ self . field_name ] = self . null_value return data","title":"API Reference"},{"location":"reference/#api-reference","text":"","title":"API Reference"},{"location":"reference/#versionedserializer","text":"Bases: serializers . Serializer Source code in drf_versioning/serializers/versioned_serializer.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class VersionedSerializer ( serializers . Serializer ): transforms : tuple [ type [ Transform ]] = None def __init__ ( self , * args , ** kwargs ): super () . __init__ ( * args , ** kwargs ) self . check_transforms_declared () def check_transforms_declared ( self ): if not self . transforms : raise TransformsNotDeclaredError ( f \" { self . __class__ . __name__ } has not declared transforms.\" ) def _get_request_version ( self ): request = self . context . get ( \"request\" ) if request and hasattr ( request , \"version\" ): return request . version def transforms_for_version ( self , version : Version , reverse = False ) -> list [ type [ Transform ]]: return sorted ( filter ( lambda transform : version < transform . version , self . transforms ), key = lambda transform : transform . version , reverse = reverse , ) def to_representation ( self , instance ): \"\"\" Serializes the outgoing data as JSON and executes any available version transforms in backwards order against the serialized representation to convert the highest supported version into the requested version of the resource. \"\"\" data = super () . to_representation ( instance ) request = self . context . get ( \"request\" ) if request_version := self . _get_request_version (): for transform in self . transforms_for_version ( version = request_version , reverse = True ): transform () . to_representation ( data , request , instance ) return data def to_internal_value ( self , data : QueryDict ): data = data . copy () # immutable QueryDict to mutable dict request = self . context . get ( \"request\" ) if request_version := self . _get_request_version (): for transform in self . transforms_for_version ( version = request_version , reverse = False ): transform () . to_internal_value ( data , request ) return super () . to_internal_value ( data )","title":"VersionedSerializer"},{"location":"reference/#drf_versioning.serializers.versioned_serializer.VersionedSerializer.to_representation","text":"Serializes the outgoing data as JSON and executes any available version transforms in backwards order against the serialized representation to convert the highest supported version into the requested version of the resource. Source code in drf_versioning/serializers/versioned_serializer.py 36 37 38 39 40 41 42 43 44 45 46 47 48 def to_representation ( self , instance ): \"\"\" Serializes the outgoing data as JSON and executes any available version transforms in backwards order against the serialized representation to convert the highest supported version into the requested version of the resource. \"\"\" data = super () . to_representation ( instance ) request = self . context . get ( \"request\" ) if request_version := self . _get_request_version (): for transform in self . transforms_for_version ( version = request_version , reverse = True ): transform () . to_representation ( data , request , instance ) return data","title":"to_representation()"},{"location":"reference/#versionedviewset","text":"Bases: viewsets . GenericViewSet Source code in drf_versioning/views/versioned_viewset.py 35 36 37 38 39 40 41 42 43 44 45 46 47 class VersionedViewSet ( viewsets . GenericViewSet , metaclass = VersionedViewSetMeta ): introduced_in : Optional [ Version ] = None removed_in : Optional [ Version ] = None def dispatch ( self , request , * args , ** kwargs ): request_method = request . method . lower () if request_method in self . http_method_names : handler = getattr ( self , request_method , self . http_method_not_allowed ) handler = versioned_view ( handler , introduced_in = self . introduced_in , removed_in = self . removed_in ) setattr ( self , request_method , handler ) return super () . dispatch ( request , * args , ** kwargs )","title":"VersionedViewSet"},{"location":"reference/#versioned_view","text":"Source code in drf_versioning/decorators/decorators.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def versioned_view ( original_obj = None , introduced_in : Version = None , removed_in : Version = None ): def decorate ( obj ): if introduced_in is None and removed_in is None : raise VersionsNotDeclaredError ( obj ) @wraps ( obj ) def func_wrapper ( * args , ** kwargs ): # if it's a bound method which we decorated dynamically: # handler = versioned_view(handler, ...) if hasattr ( obj , \"__self__\" ): request = args [ 0 ] viewset = obj . __self__ # if it's an unbound function we decorated statically at class definition: # @versioned_view(...) # def list(...): # ... else : viewset , request = args viewset_introduced_in = getattr ( viewset , \"introduced_in\" , None ) viewset_removed_in = getattr ( viewset , \"removed_in\" , None ) min_version = get_min_version ( introduced_in , viewset_introduced_in ) max_version = get_max_version ( removed_in , viewset_removed_in ) if min_version and request . version < min_version : raise Http404 () if max_version and request . version >= max_version : raise Http404 () output = obj ( * args , ** kwargs ) return output if introduced_in : introduced_in . view_methods_introduced . append ( func_wrapper ) if removed_in : removed_in . view_methods_removed . append ( func_wrapper ) return func_wrapper return decorate ( original_obj ) if original_obj else decorate","title":"versioned_view"},{"location":"reference/#transforms","text":"Mutates serializer data between different versions Source code in drf_versioning/transforms/transform.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Transform ( metaclass = TransformMeta ): \"\"\" Mutates serializer data between different versions \"\"\" description : str # will be added to version.notes version : Version # will be added to version.transforms def to_internal_value ( self , data : dict , request ): \"\"\"Operation performed on incoming data from older request versions\"\"\" raise NotImplementedError def to_representation ( self , data : dict , request , instance ): \"\"\"Operation performed on outgoing data in response to an older request version\"\"\" raise NotImplementedError","title":"Transforms"},{"location":"reference/#drf_versioning.transforms.transform.Transform.to_internal_value","text":"Operation performed on incoming data from older request versions Source code in drf_versioning/transforms/transform.py 25 26 27 def to_internal_value ( self , data : dict , request ): \"\"\"Operation performed on incoming data from older request versions\"\"\" raise NotImplementedError","title":"to_internal_value()"},{"location":"reference/#drf_versioning.transforms.transform.Transform.to_representation","text":"Operation performed on outgoing data in response to an older request version Source code in drf_versioning/transforms/transform.py 29 30 31 def to_representation ( self , data : dict , request , instance ): \"\"\"Operation performed on outgoing data in response to an older request version\"\"\" raise NotImplementedError Bases: Transform Source code in drf_versioning/transforms/common.py 4 5 6 7 8 9 10 11 12 13 class AddField ( Transform ): field_name : str def to_internal_value ( self , data : dict , request ): data . pop ( self . field_name , None ) return data def to_representation ( self , data : dict , request , instance ): data . pop ( self . field_name , None ) return data Bases: Transform Source code in drf_versioning/transforms/common.py 16 17 18 19 20 21 22 23 24 25 26 class RemoveField ( Transform ): field_name : str null_value = None # the value to serialize for the removed field for old versions def to_internal_value ( self , data : dict , request ): data . pop ( self . field_name , None ) return data def to_representation ( self , data : dict , request , instance ): data [ self . field_name ] = self . null_value return data","title":"to_representation()"},{"location":"how-to-guides/how-to-foo/","text":"","title":"How to foo"},{"location":"how-to-guides/how-to-guides/","text":"Foo","title":"How to guides"},{"location":"tutorials/installation/","text":"Installation Add djangorestframework-versioning to your requirements.txt. Create a versioning module. This can be a django app, but it doesn't have to be, since we don't require any models. In the project root, do: mkdir versioning In versioning/versions.py : from drf_versioning.versions import Version VERSION_1_0_0 = Version( \"1.0.0\", notes=[\"Initial version :)\"], ) in versioning.version_list.py : from . import versions VERSIONS = [ versions.VERSION_1_0_0, ] Add the following line to your mysite/settings.py . # Here we are telling rest_framework to use drf_versioning's AcceptHeaderVersioning class. It # inherits from rest_framework's AcceptHeaderVersioning class, and does almost the same thing, # but it adds the ability to choose a default version if the version is not specified in the # request. REST_FRAMEWORK = { \"DEFAULT_VERSIONING_CLASS\": \"drf_versioning.middleware.AcceptHeaderVersioning\", } # Here we are telling drf_versioning where to find our list of supported versions ( # `VERSION_LIST`). We also specify a default version that we would like to attach to requests # that do not specify a version. We have selected \"latest\" which will use the most recent Version # it can find in the supported versions list. Other acceptable values are \"earliest\" or a version # string e.g. \"1.0.0\" DRF_VERSIONING_SETTINGS = { \"VERSION_LIST\": \"versioning.version_list.VERSIONS\", \"DEFAULT_VERSION\": \"latest\", } In mysite/urls.py , add drf_versioning s default urls. Your urlpatterns should now look like this: urlpatterns = [ path(\"admin/\", admin.site.urls), path(\"doggies/\", include(\"doggies.urls\")), path(\"version/\", include(\"drf_versioning.urls\")), ] If we navigate to http://localhost:8000/version/ , we should see a list of available versions, with a description of the changes in each version. The notes that we passed to the Version instance are also serialized here. [ { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } } ] If we navigate to http://localhost:8000/version/my_version/ , we should see which version was assigned to our request. Since we did not specify a versoin, we have been assigned the latest version -- 1.0.0 (which is also the only version). { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } } Now that we have completed the setup, we can start the interesting part -- making changes to our API and supporting multiple versions!","title":"Installation"},{"location":"tutorials/installation/#installation","text":"Add djangorestframework-versioning to your requirements.txt. Create a versioning module. This can be a django app, but it doesn't have to be, since we don't require any models. In the project root, do: mkdir versioning In versioning/versions.py : from drf_versioning.versions import Version VERSION_1_0_0 = Version( \"1.0.0\", notes=[\"Initial version :)\"], ) in versioning.version_list.py : from . import versions VERSIONS = [ versions.VERSION_1_0_0, ] Add the following line to your mysite/settings.py . # Here we are telling rest_framework to use drf_versioning's AcceptHeaderVersioning class. It # inherits from rest_framework's AcceptHeaderVersioning class, and does almost the same thing, # but it adds the ability to choose a default version if the version is not specified in the # request. REST_FRAMEWORK = { \"DEFAULT_VERSIONING_CLASS\": \"drf_versioning.middleware.AcceptHeaderVersioning\", } # Here we are telling drf_versioning where to find our list of supported versions ( # `VERSION_LIST`). We also specify a default version that we would like to attach to requests # that do not specify a version. We have selected \"latest\" which will use the most recent Version # it can find in the supported versions list. Other acceptable values are \"earliest\" or a version # string e.g. \"1.0.0\" DRF_VERSIONING_SETTINGS = { \"VERSION_LIST\": \"versioning.version_list.VERSIONS\", \"DEFAULT_VERSION\": \"latest\", } In mysite/urls.py , add drf_versioning s default urls. Your urlpatterns should now look like this: urlpatterns = [ path(\"admin/\", admin.site.urls), path(\"doggies/\", include(\"doggies.urls\")), path(\"version/\", include(\"drf_versioning.urls\")), ] If we navigate to http://localhost:8000/version/ , we should see a list of available versions, with a description of the changes in each version. The notes that we passed to the Version instance are also serialized here. [ { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } } ] If we navigate to http://localhost:8000/version/my_version/ , we should see which version was assigned to our request. Since we did not specify a versoin, we have been assigned the latest version -- 1.0.0 (which is also the only version). { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } } Now that we have completed the setup, we can start the interesting part -- making changes to our API and supporting multiple versions!","title":"Installation"},{"location":"tutorials/sample-django-project/","text":"Sample Django project setup To showcase the features of this library, we will set up a basic Django Rest Framework project. If you want to install DRF Versioning into an existing project, or if you just need a quick reference, feel free to skip this and use the Quick Start page instead. The Django tutorial may also be helpful if you are doing this for the first time. Create a project directory and a virtual environment , and inside it create requirements.txt with the following contents: django djangorestframework djangorestframework-versioning and run pip install -r requirements.txt django-admin startproject mysite start doggies app ./manage.py startapp doggies Add \"doggies\" to settings.INSTALLED_APPS Create doggies/models.py with contents: from django.db import models from datetime import date class Dog(models.Model): name = models.CharField(max_length=50) birthday = models.DateField(default=date.today) def __str__(self): return self.name.title() Create doggies/serializers.py with contents: from rest_framework import serializers from doggies.models import Dog class DogSerializer(serializers.ModelSerializer): class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", ) Create doggies/admin.py with contents: from django.contrib import admin from doggies.models import Dog @admin.register(Dog) class DogAdmin(admin.ModelAdmin): pass Create doggies/views.py with contents: from rest_framework import viewsets, mixins from doggies.models import Dog from doggies.serializers import DogSerializer class DoggieViewSet(viewsets.GenericViewSet, mixins.ListModelMixin): serializer_class = DogSerializer queryset = Dog.objects.all() Create doggies/urls.py with contents: from rest_framework.routers import DefaultRouter from . import views router = DefaultRouter() router.register(\"\", views.DoggieViewSet, basename=\"doggies\") urlpatterns = router.urls Register our doggies app urls in the global project urls mysite/urls.py : from django.contrib import admin from django.urls import path, include urlpatterns = [ path(\"admin/\", admin.site.urls), path(\"doggies/\", include(\"doggies.urls\")), ] Your project directory should now look like this: \u251c\u2500\u2500 db.sqlite3 \u251c\u2500\u2500 doggies \u2502 \u251c\u2500\u2500 admin.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 migrations \u2502 \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 serializers.py \u2502 \u251c\u2500\u2500 tests.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 views.py \u251c\u2500\u2500 manage.py \u251c\u2500\u2500 mysite \u2502 \u251c\u2500\u2500 asgi.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 wsgi.py \u2514\u2500\u2500 requirements.txt Create the new Dog table in the database: ./manage.py makemigrations ./manage.py migrate create superuser ./manage.py createsuperuser create some dogs in the admin site Now if we navigate to localhost:8000/doggies/ we should see the following output:","title":"Sample Django project setup"},{"location":"tutorials/sample-django-project/#sample-django-project-setup","text":"To showcase the features of this library, we will set up a basic Django Rest Framework project. If you want to install DRF Versioning into an existing project, or if you just need a quick reference, feel free to skip this and use the Quick Start page instead. The Django tutorial may also be helpful if you are doing this for the first time. Create a project directory and a virtual environment , and inside it create requirements.txt with the following contents: django djangorestframework djangorestframework-versioning and run pip install -r requirements.txt django-admin startproject mysite start doggies app ./manage.py startapp doggies Add \"doggies\" to settings.INSTALLED_APPS Create doggies/models.py with contents: from django.db import models from datetime import date class Dog(models.Model): name = models.CharField(max_length=50) birthday = models.DateField(default=date.today) def __str__(self): return self.name.title() Create doggies/serializers.py with contents: from rest_framework import serializers from doggies.models import Dog class DogSerializer(serializers.ModelSerializer): class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", ) Create doggies/admin.py with contents: from django.contrib import admin from doggies.models import Dog @admin.register(Dog) class DogAdmin(admin.ModelAdmin): pass Create doggies/views.py with contents: from rest_framework import viewsets, mixins from doggies.models import Dog from doggies.serializers import DogSerializer class DoggieViewSet(viewsets.GenericViewSet, mixins.ListModelMixin): serializer_class = DogSerializer queryset = Dog.objects.all() Create doggies/urls.py with contents: from rest_framework.routers import DefaultRouter from . import views router = DefaultRouter() router.register(\"\", views.DoggieViewSet, basename=\"doggies\") urlpatterns = router.urls Register our doggies app urls in the global project urls mysite/urls.py : from django.contrib import admin from django.urls import path, include urlpatterns = [ path(\"admin/\", admin.site.urls), path(\"doggies/\", include(\"doggies.urls\")), ] Your project directory should now look like this: \u251c\u2500\u2500 db.sqlite3 \u251c\u2500\u2500 doggies \u2502 \u251c\u2500\u2500 admin.py \u2502 \u251c\u2500\u2500 apps.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 migrations \u2502 \u2502 \u251c\u2500\u2500 0001_initial.py \u2502 \u2502 \u2514\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 models.py \u2502 \u251c\u2500\u2500 serializers.py \u2502 \u251c\u2500\u2500 tests.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 views.py \u251c\u2500\u2500 manage.py \u251c\u2500\u2500 mysite \u2502 \u251c\u2500\u2500 asgi.py \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 settings.py \u2502 \u251c\u2500\u2500 urls.py \u2502 \u2514\u2500\u2500 wsgi.py \u2514\u2500\u2500 requirements.txt Create the new Dog table in the database: ./manage.py makemigrations ./manage.py migrate create superuser ./manage.py createsuperuser create some dogs in the admin site Now if we navigate to localhost:8000/doggies/ we should see the following output:","title":"Sample Django project setup"},{"location":"tutorials/serializers/","text":"Versioning models / serializers At some point we will need to make changes to our models in order to add new features. But we also want to keep supporting older API versions. drf_versioning acts as a \"versioning layer\" in this regard. Adding a new field Let's add a new age property to the Dog model. from django.db import models from datetime import date from django.utils import timezone class Dog(models.Model): name = models.CharField(max_length=50) birthday = models.DateField(default=date.today) def __str__(self): return self.name.title() @property def age(self): return (timezone.now().date() - self.birthday).days // 365 And add the age field to the DogSerializer in doggies/serializers.py : class DogSerializer(serializers.ModelSerializer): age = serializers.IntegerField() class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) But we don't want to break old API versions with this unexpected new field. So we create a new Version and only serialize this field if the request.version is greater. in versions.py : VERSION_2_1_0 = Version( \"2.1.0\", notes=[\"Added Dog.age property\"], ) Now create a new file doggies/transforms.py , with the following content: from drf_versioning.transforms import Transform from versioning import versions class AddAge(Transform): version = versions.VERSION_2_1_0 description = \"Added Dog.age which is auto-calculated based on the Dog's birthday.\" def to_representation(self, data: dict, request, instance): \"\"\" Here we downgrade the serializer's output data to make it match older API versions. In this case that means removing the new 'age' field. \"\"\" data.pop(\"age\", None) return data def to_internal_value(self, data: dict, request): \"\"\" Here we upgrade the request.data to make it match the latest API version. In this case the 'age' field is read-only, so no action is required. \"\"\" pass And update the DogSerializer in doggies/serializers.py : from drf_versioning.serializers import VersionedSerializer from rest_framework import serializers from doggies.models import Dog from . import transforms class DogSerializer(VersionedSerializer, serializers.ModelSerializer): age = serializers.IntegerField() transforms = ( transforms.AddAge, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) Here we have done: DogSerializer now inherits from VersionedSerializer We have declared a tuple of Transform objects that apply to this serializer The serializer code reflects the latest behaviour The Transforms downgrade the output for older request versions In Postman: GET /doggies/1/ with version = 2.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" } In Postman: GET /doggies/1/ with version = 2.1.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": 8 } Because adding a new field is bound to a relatively common operation, DRF Versioning provides a special AddField class. Instead of our Transform subclass above, we could also have done this: from drf_versioning.transforms import AddField from versioning import versions class AddAge(AddField): version = versions.VERSION_2_1_0 field_name = \"age\" description = \"Added Dog.age which is auto-calculated based on the Dog's birthday.\" and it would have had the same effect. The Transform object adds its description field to the Version instance's models changelog: { \"version\": \"2.1.0\", \"notes\": [], \"models\": [ \"Added Dog.age which is auto-calculated based on the Dog's birthday.\" ], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } }, Mutating fields Let's say we want to update the Dog model to provide a dog_years property: class Dog(models.Model): ... @property def dog_years(self): return self.age * 7 and we want to group this together with the age property like this: { \"age\": { \"human_years\": 8, \"dog_years\": 56 } } First let's update the serializers in doggies/serializers.py : from drf_versioning.serializers import VersionedSerializer from rest_framework import serializers from doggies.models import Dog from . import transforms class DogAgeSerializer(serializers.Serializer): def to_representation(self, instance): return {\"human_years\": instance.age, \"dog_years\": instance.dog_years} class DogSerializer(VersionedSerializer, serializers.ModelSerializer): age = DogAgeSerializer(source=\"*\") transforms = ( transforms.AddAge, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) Our serializer now produces the desired output: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": 8, \"dog_years\": 56 } } But we need a transform to downgrade this data for older API versions. In doggies/transforms.py , we add: class GroupAgeAndDogYears(Transform): version = versions.VERSION_3_0_0 description = ( \"Added Dog.dog_years and grouped Dog.age and Dog.dog_years into one 'age' property\" ) def to_representation(self, data: dict, request, instance): \"\"\" Here we downgrade the serializer's output data to make it match older API versions. In this case that means returning the Dog.age value instead of the whole {\"human_years\": 1, \"dog_years\": 7} dict. \"\"\" data[\"age\"] = data[\"age\"][\"human_years\"] return data def to_internal_value(self, data: dict, request): \"\"\" Here we upgrade the request.data to make it match the latest API version. In this case the 'age' field is read-only, so no action is required. \"\"\" pass We add this transform to the DogSerializer: class DogSerializer(VersionedSerializer, serializers.ModelSerializer): age = DogAgeSerializer(source=\"*\") transforms = ( transforms.AddAge, transforms.GroupAgeAndDogYears, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) Let's test the endpoint's behaviour. In Postman: GET /doggies/1/ with version = 2.1.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": 8 } In Postman: GET /doggies/1/ with version = 3.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": 8, \"dog_years\": 56 } } Removing a field Let's say we've decided to remove the age field altogether, and let the API consumer work it out for themselves based on the birthday field. In doggies/transforms.py : class RemoveAge(Transform): version = versions.VERSION_4_0_0 description = \"Removed Dog.age field\" def to_representation(self, data: dict, request, instance): \"\"\" Here we downgrade the serializer's output data to make it match older API versions. We have removed the field, but older versions are still expecting it. So we add it to the serializer output for older versions here. \"\"\" data[\"age\"] = { \"human_years\": instance.age, \"dog_years\": instance.dog_years, } return data In doggies/serializers.py : from drf_versioning.serializers import VersionedSerializer from rest_framework import serializers from doggies.models import Dog from . import transforms class DogSerializer(VersionedSerializer, serializers.ModelSerializer): transforms = ( transforms.AddAge, transforms.GroupAgeAndDogYears, transforms.RemoveAge, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", # \"age\", # <---- remove this field ) The resulting behaviour of the API is: In Postman: GET /doggies/1/ with version = 3.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": 8, \"dog_years\": 56 } } In Postman: GET /doggies/1/ with version = 4.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" } In this example, we still have access to the Dog.age and Dog.dog_years properties, so we can continue serializing real values for older request versions. But let's say the property has been removed, and we completely lose access to the source data. We can no longer serialize the dog's age for older versions. In this case we can instead serialize a \"null value\" that satisfies the type and structure that the older version is expecting. For Dog.age, we could use -1 , for example. DRF Versioning provides another built in Transform subclass for this case: RemoveField . We can recreate the behaviour of our RemoveAge transform like this: class RemoveAge(RemoveField): version = versions.VERSION_4_0_0 field_name = \"age\" description = \"Removed Dog.age field\" null_value = {\"human_years\": -1, \"dog_years\": -1} Now is a good time to check that our Transforms correctly cascade their changes through all API versions. In Postman: GET /doggies/1/ with version = 1.0.0: { \"detail\": \"Not found.\" } In Postman: GET /doggies/1/ with version = 2.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" } In Postman: GET /doggies/1/ with version = 2.1.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": -1 } In Postman: GET /doggies/1/ with version = 3.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": -1, \"dog_years\": -1 } } In Postman: GET /doggies/1/ with version = 4.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" }","title":"Versioning models / serializers"},{"location":"tutorials/serializers/#versioning-models-serializers","text":"At some point we will need to make changes to our models in order to add new features. But we also want to keep supporting older API versions. drf_versioning acts as a \"versioning layer\" in this regard.","title":"Versioning models / serializers"},{"location":"tutorials/serializers/#adding-a-new-field","text":"Let's add a new age property to the Dog model. from django.db import models from datetime import date from django.utils import timezone class Dog(models.Model): name = models.CharField(max_length=50) birthday = models.DateField(default=date.today) def __str__(self): return self.name.title() @property def age(self): return (timezone.now().date() - self.birthday).days // 365 And add the age field to the DogSerializer in doggies/serializers.py : class DogSerializer(serializers.ModelSerializer): age = serializers.IntegerField() class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) But we don't want to break old API versions with this unexpected new field. So we create a new Version and only serialize this field if the request.version is greater. in versions.py : VERSION_2_1_0 = Version( \"2.1.0\", notes=[\"Added Dog.age property\"], ) Now create a new file doggies/transforms.py , with the following content: from drf_versioning.transforms import Transform from versioning import versions class AddAge(Transform): version = versions.VERSION_2_1_0 description = \"Added Dog.age which is auto-calculated based on the Dog's birthday.\" def to_representation(self, data: dict, request, instance): \"\"\" Here we downgrade the serializer's output data to make it match older API versions. In this case that means removing the new 'age' field. \"\"\" data.pop(\"age\", None) return data def to_internal_value(self, data: dict, request): \"\"\" Here we upgrade the request.data to make it match the latest API version. In this case the 'age' field is read-only, so no action is required. \"\"\" pass And update the DogSerializer in doggies/serializers.py : from drf_versioning.serializers import VersionedSerializer from rest_framework import serializers from doggies.models import Dog from . import transforms class DogSerializer(VersionedSerializer, serializers.ModelSerializer): age = serializers.IntegerField() transforms = ( transforms.AddAge, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) Here we have done: DogSerializer now inherits from VersionedSerializer We have declared a tuple of Transform objects that apply to this serializer The serializer code reflects the latest behaviour The Transforms downgrade the output for older request versions In Postman: GET /doggies/1/ with version = 2.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" } In Postman: GET /doggies/1/ with version = 2.1.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": 8 } Because adding a new field is bound to a relatively common operation, DRF Versioning provides a special AddField class. Instead of our Transform subclass above, we could also have done this: from drf_versioning.transforms import AddField from versioning import versions class AddAge(AddField): version = versions.VERSION_2_1_0 field_name = \"age\" description = \"Added Dog.age which is auto-calculated based on the Dog's birthday.\" and it would have had the same effect. The Transform object adds its description field to the Version instance's models changelog: { \"version\": \"2.1.0\", \"notes\": [], \"models\": [ \"Added Dog.age which is auto-calculated based on the Dog's birthday.\" ], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } },","title":"Adding a new field"},{"location":"tutorials/serializers/#mutating-fields","text":"Let's say we want to update the Dog model to provide a dog_years property: class Dog(models.Model): ... @property def dog_years(self): return self.age * 7 and we want to group this together with the age property like this: { \"age\": { \"human_years\": 8, \"dog_years\": 56 } } First let's update the serializers in doggies/serializers.py : from drf_versioning.serializers import VersionedSerializer from rest_framework import serializers from doggies.models import Dog from . import transforms class DogAgeSerializer(serializers.Serializer): def to_representation(self, instance): return {\"human_years\": instance.age, \"dog_years\": instance.dog_years} class DogSerializer(VersionedSerializer, serializers.ModelSerializer): age = DogAgeSerializer(source=\"*\") transforms = ( transforms.AddAge, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) Our serializer now produces the desired output: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": 8, \"dog_years\": 56 } } But we need a transform to downgrade this data for older API versions. In doggies/transforms.py , we add: class GroupAgeAndDogYears(Transform): version = versions.VERSION_3_0_0 description = ( \"Added Dog.dog_years and grouped Dog.age and Dog.dog_years into one 'age' property\" ) def to_representation(self, data: dict, request, instance): \"\"\" Here we downgrade the serializer's output data to make it match older API versions. In this case that means returning the Dog.age value instead of the whole {\"human_years\": 1, \"dog_years\": 7} dict. \"\"\" data[\"age\"] = data[\"age\"][\"human_years\"] return data def to_internal_value(self, data: dict, request): \"\"\" Here we upgrade the request.data to make it match the latest API version. In this case the 'age' field is read-only, so no action is required. \"\"\" pass We add this transform to the DogSerializer: class DogSerializer(VersionedSerializer, serializers.ModelSerializer): age = DogAgeSerializer(source=\"*\") transforms = ( transforms.AddAge, transforms.GroupAgeAndDogYears, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", \"age\", ) Let's test the endpoint's behaviour. In Postman: GET /doggies/1/ with version = 2.1.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": 8 } In Postman: GET /doggies/1/ with version = 3.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": 8, \"dog_years\": 56 } }","title":"Mutating fields"},{"location":"tutorials/serializers/#removing-a-field","text":"Let's say we've decided to remove the age field altogether, and let the API consumer work it out for themselves based on the birthday field. In doggies/transforms.py : class RemoveAge(Transform): version = versions.VERSION_4_0_0 description = \"Removed Dog.age field\" def to_representation(self, data: dict, request, instance): \"\"\" Here we downgrade the serializer's output data to make it match older API versions. We have removed the field, but older versions are still expecting it. So we add it to the serializer output for older versions here. \"\"\" data[\"age\"] = { \"human_years\": instance.age, \"dog_years\": instance.dog_years, } return data In doggies/serializers.py : from drf_versioning.serializers import VersionedSerializer from rest_framework import serializers from doggies.models import Dog from . import transforms class DogSerializer(VersionedSerializer, serializers.ModelSerializer): transforms = ( transforms.AddAge, transforms.GroupAgeAndDogYears, transforms.RemoveAge, ) class Meta: model = Dog fields = ( \"id\", \"name\", \"birthday\", # \"age\", # <---- remove this field ) The resulting behaviour of the API is: In Postman: GET /doggies/1/ with version = 3.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": 8, \"dog_years\": 56 } } In Postman: GET /doggies/1/ with version = 4.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" } In this example, we still have access to the Dog.age and Dog.dog_years properties, so we can continue serializing real values for older request versions. But let's say the property has been removed, and we completely lose access to the source data. We can no longer serialize the dog's age for older versions. In this case we can instead serialize a \"null value\" that satisfies the type and structure that the older version is expecting. For Dog.age, we could use -1 , for example. DRF Versioning provides another built in Transform subclass for this case: RemoveField . We can recreate the behaviour of our RemoveAge transform like this: class RemoveAge(RemoveField): version = versions.VERSION_4_0_0 field_name = \"age\" description = \"Removed Dog.age field\" null_value = {\"human_years\": -1, \"dog_years\": -1} Now is a good time to check that our Transforms correctly cascade their changes through all API versions. In Postman: GET /doggies/1/ with version = 1.0.0: { \"detail\": \"Not found.\" } In Postman: GET /doggies/1/ with version = 2.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" } In Postman: GET /doggies/1/ with version = 2.1.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": -1 } In Postman: GET /doggies/1/ with version = 3.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\", \"age\": { \"human_years\": -1, \"dog_years\": -1 } } In Postman: GET /doggies/1/ with version = 4.0.0: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2014-05-06\" }","title":"Removing a field"},{"location":"tutorials/views/","text":"Versioning views View actions / methods Let's say we want to add a new action to the Dogs viewset -- a view for individual dogs. Paste the following code into your doggies/views.py : from drf_versioning.decorators import versioned_view from rest_framework import viewsets, mixins from doggies.models import Dog from doggies.serializers import DogSerializer from versioning import versions class DoggieViewSet(viewsets.GenericViewSet, mixins.ListModelMixin, mixins.RetrieveModelMixin): serializer_class = DogSerializer queryset = Dog.objects.all() @versioned_view(introduced_in=versions.VERSION_2_0_0) def retrieve(self, request, *args, **kwargs): return super().retrieve(request, *args, **kwargs) Here we have Added the RetrieveModelMixin to the viewset, which allows us to see the detail view at /doggies/<dog-id>/ Overridden the retrieve method and applied the versioned_view decorator, specifying the version from which this view should become available. Version 2.0.0 doesn't exist yet, so let's create it. Add this to your versioning/versions.py : VERSION_2_0_0 = Version( \"2.0.0\", notes=[\"Added doggie detail view\"], ) and add it to the list of supported versions in versioning/version_list.py : VERSIONS = [ versions.VERSION_2_0_0, versions.VERSION_1_0_0, ] Now if we ping the /version/ endpoint, we should see the new Version. Note that in addition to the notes which we added to the Version instance by hand, the versioned_view decorator has also informed the Version instance about the new view, and it is described in the views.actions_introduced list. [ { \"version\": \"2.0.0\", \"notes\": [ \"Added doggie detail view\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [ \"DoggieViewSet.retrieve\" ], \"actions_removed\": [] } }, { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } } ] The versioned_view decorator hides the view for requests with version < 2.0.0. We can demonstrate this by requesting GET /doggies/1/ with Accept: application/json; version=1.0.0 in Postman. We get a 404 response with the following body: { \"detail\": \"Not found.\" } If we repeat the same request with Accept: application/json; version=2.0.0 , we are given access to the view: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2023-01-30\" } The versioned_view decorator also accepts a removed_in argument. If this is present, the view will be hidden for all requests whose version is greater. ViewSets If we want to introduce / remove a whole endpoint, we can achieve this by inheriting from the VersionedViewSet class. In this case the introduced_in and removed_in versions are set as class attributes, which also apply to any of the ViewSet's methods: class CatViewSet(VersionedViewSet, viewsets.ReadOnlyModelViewSet): serializer_class = CatSerializer queryset = Cat.objects.all() introduced_in = versions.VERSION_1_0_0 removed_in = versions.VERSION_5_0_0 @versioned_view(introduced_in=versions.VERSION_3_0_0) def retrieve(self, request, *args, **kwargs): return super().retrieve(request, *args, **kwargs) @versioned_view(removed_in=versions.VERSION_4_0_0) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) However, individual methods can be further limited by using the versioned_view decorator. The most restrictive combination of viewset / method versions will be chosen. In this example this results in: CatViewSet is available from 1.0.0 to 5.0.0 retrieve is available from 3.0.0 to 5.0.0 list is available from 1.0.0 to 4.0.0 The VersionedViewSet class also informs the relevant Version instances about its introduction and removal. It appears under views.endpoints_introduced / views.endpoints_removed in a serialized Version: { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [ \"CatViewSet\" ], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } }","title":"Versioning views"},{"location":"tutorials/views/#versioning-views","text":"","title":"Versioning views"},{"location":"tutorials/views/#view-actions-methods","text":"Let's say we want to add a new action to the Dogs viewset -- a view for individual dogs. Paste the following code into your doggies/views.py : from drf_versioning.decorators import versioned_view from rest_framework import viewsets, mixins from doggies.models import Dog from doggies.serializers import DogSerializer from versioning import versions class DoggieViewSet(viewsets.GenericViewSet, mixins.ListModelMixin, mixins.RetrieveModelMixin): serializer_class = DogSerializer queryset = Dog.objects.all() @versioned_view(introduced_in=versions.VERSION_2_0_0) def retrieve(self, request, *args, **kwargs): return super().retrieve(request, *args, **kwargs) Here we have Added the RetrieveModelMixin to the viewset, which allows us to see the detail view at /doggies/<dog-id>/ Overridden the retrieve method and applied the versioned_view decorator, specifying the version from which this view should become available. Version 2.0.0 doesn't exist yet, so let's create it. Add this to your versioning/versions.py : VERSION_2_0_0 = Version( \"2.0.0\", notes=[\"Added doggie detail view\"], ) and add it to the list of supported versions in versioning/version_list.py : VERSIONS = [ versions.VERSION_2_0_0, versions.VERSION_1_0_0, ] Now if we ping the /version/ endpoint, we should see the new Version. Note that in addition to the notes which we added to the Version instance by hand, the versioned_view decorator has also informed the Version instance about the new view, and it is described in the views.actions_introduced list. [ { \"version\": \"2.0.0\", \"notes\": [ \"Added doggie detail view\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [ \"DoggieViewSet.retrieve\" ], \"actions_removed\": [] } }, { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } } ] The versioned_view decorator hides the view for requests with version < 2.0.0. We can demonstrate this by requesting GET /doggies/1/ with Accept: application/json; version=1.0.0 in Postman. We get a 404 response with the following body: { \"detail\": \"Not found.\" } If we repeat the same request with Accept: application/json; version=2.0.0 , we are given access to the view: { \"id\": 1, \"name\": \"Biko\", \"birthday\": \"2023-01-30\" } The versioned_view decorator also accepts a removed_in argument. If this is present, the view will be hidden for all requests whose version is greater.","title":"View actions / methods"},{"location":"tutorials/views/#viewsets","text":"If we want to introduce / remove a whole endpoint, we can achieve this by inheriting from the VersionedViewSet class. In this case the introduced_in and removed_in versions are set as class attributes, which also apply to any of the ViewSet's methods: class CatViewSet(VersionedViewSet, viewsets.ReadOnlyModelViewSet): serializer_class = CatSerializer queryset = Cat.objects.all() introduced_in = versions.VERSION_1_0_0 removed_in = versions.VERSION_5_0_0 @versioned_view(introduced_in=versions.VERSION_3_0_0) def retrieve(self, request, *args, **kwargs): return super().retrieve(request, *args, **kwargs) @versioned_view(removed_in=versions.VERSION_4_0_0) def list(self, request, *args, **kwargs): return super().list(request, *args, **kwargs) However, individual methods can be further limited by using the versioned_view decorator. The most restrictive combination of viewset / method versions will be chosen. In this example this results in: CatViewSet is available from 1.0.0 to 5.0.0 retrieve is available from 3.0.0 to 5.0.0 list is available from 1.0.0 to 4.0.0 The VersionedViewSet class also informs the relevant Version instances about its introduction and removal. It appears under views.endpoints_introduced / views.endpoints_removed in a serialized Version: { \"version\": \"1.0.0\", \"notes\": [ \"Initial version :)\" ], \"models\": [], \"views\": { \"endpoints_introduced\": [ \"CatViewSet\" ], \"endpoints_removed\": [], \"actions_introduced\": [], \"actions_removed\": [] } }","title":"ViewSets"}]}